using dnlib.DotNet;
using System;
using System.IO;
using System.Linq;
using System.Text;

/// <summary>
/// Name: ProxyGenerator
/// Description: DotNet Assembly To Cpp Header Generator
/// Author: Gorav Gupta
/// </summary>

namespace ProxyGenerator
{
    public class ProxyGenerator
    {
        public static void AssemblyToHeader(string path, bool generateMethod)
        {
            ModuleDef module = ModuleDefMD.Load(path);

            StringBuilder stringBuilder = new StringBuilder();
            StringBuilder stringBuilder2 = new StringBuilder();

            StringBuilder LogOutPut = new StringBuilder();

            foreach (var typedef in module.Types)
            {
                if (AnalyzeMember(typedef)) // Analyze it, type is supported?
                {
                    string tDef = typedef.ToString().Replace(".", "/").Replace("`", "_");
                    string tDef2 = (typedef.ToString() + "::_" + typedef.Name).Replace(".", "::").Replace("`", "_");

                    stringBuilder.AppendLine("#include " + "\"" + tDef + ".h" + "\"");
                    stringBuilder2.AppendLine("    " + tDef2 + " = pFind_Type(_assemblyPtr, " + "\"" + typedef.ToString() + "\"" + ");");

                    string tNamespace = typedef.Namespace.ToString().Replace(".", "::").Replace("`", "_");

                    string FormatH;
                    if (tNamespace.Length > 0)
                    {
                        FormatH =
                    "/// <summary>\n" +
                    "/// Name: " + typedef.Namespace.ToString().Replace(".", "::").Replace("`", "_") + "::" + typedef.Name.Replace("`", "_") + "\n" +
                    "/// Generated By: ProxyGenerator\n" +
                    "/// Notice: Don't edit\n" +
                    "/// <summary>\n\n" +
                    "#pragma once\n" +
                    "#include \"DotNetHelper.h\"\n" +
                    "\n" +
                    "namespace " + typedef.Namespace.ToString().Replace(".", "::").Replace("`", "_") + "\n" +
                    "{\n" +
                    "	class " + typedef.Name.Replace("`", "_") + "\n" +
                    "	{\n" +
                    "	public:\n" +
                    "       inline static _TypePtr _" + typedef.Name.Replace("`", "_") + ";\n" +

                    GenerateMethodInfo(generateMethod, typedef, tDef2) +

                    "	};\n" +
                    "}\n";
                    }
                    else
                    {
                        FormatH =
                    "/// <summary>\n" +
                    "/// Name: " + typedef.Name.Replace("`", "_") + "\n" +
                    "/// Generated By: ProxyGenerator\n" +
                    "/// Notice: Don't edit\n " +
                    "/// <summary>\n\n" +
                    "#pragma once\n" +
                    "#include \"DotNetHelper.h\"\n" +
                    "\n" +
                    "class " + typedef.Name.Replace("`", "_") + "\n" +
                    "{\n" +
                    "	public:\n" +
                    "       inline static _TypePtr _" + typedef.Name.Replace("`", "_") + ";\n" +

                    GenerateMethodInfo(generateMethod, typedef, "_" + typedef.Name.Replace("`", "_")) + "\n" +

                    "};\n";
                    }

                    string str = Path.Combine(module.Assembly.Name, typedef.Namespace.ToString().Replace(".", "\\"));

                    Directory.CreateDirectory(str);

                    try
                    {
                        // write all header to file
                        File.WriteAllText(Path.Combine(str, typedef.Name.Replace("`", "_") + ".h"), FormatH, Encoding.UTF8);
                    }
                    catch (Exception ex)
                    {
                        LogOutPut.AppendLine(typedef.Name.Replace("`", "_") + ".h" + ":\n" + ex.ToString() + "\n\n" + FormatH + "\n\n\n");
                    }
                }
            }

            // Generate Initialize header
            string FormatH2 =
                    "/// <summary>\n" +
                    "/// Name: Initialize\n" +
                    "/// Generated By: ProxyGenerator\n" +
                    "/// Notice: Don't edit\n" +
                    "/// <summary>\n\n" +
                    "#pragma once\n" +
                    "#include \"DotNetHelper.h\"\n" +
                    "\n" +
                    stringBuilder.ToString() +
                    "\n" +
                    "\n" +
                    "void Initialize(_AssemblyPtr _assemblyPtr)\n" +
                    "{\n" +
                    stringBuilder2.ToString() +
                    "}\n";

            // write Generated Initialize header to file
            File.WriteAllText(Path.Combine(module.Assembly.Name, "Initialize.h"), FormatH2);

            if (LogOutPut.ToString().Length > 0)
                File.WriteAllText(module.Assembly.Name + ".log", LogOutPut.ToString());
        }

        static string GenerateMethodInfo(bool generateMethod, TypeDef type, string typeFullName)
        {
            if (!generateMethod)
                return "";
            StringBuilder stringBuilder = new StringBuilder();

            for (int i = 0; i < type.Methods.Count; i++)
            {
                var meth = type.Methods[i];
                if (AnalyzeMethod(meth, type)) // Analyze method, method is supported?
                {
                    GenerateParmIncludeList(stringBuilder, meth, type);

                    string h = "\n" +
        "/* " + meth.FullName + " */\n" +
        "	public:\n" +
        "       static _MethodInfo* " + meth.Name + "_" + Random.GetRandomString(10) /* fix: equals name error */ + "(ICorRuntimeHost* pCorRuntimeHost)\n" +
        "       {\n" +
        "			HRESULT hr;\n" +
        "			_TypePtr methodfindInType = " + typeFullName + ";\n" +
        "			bstr_t methodName = L" + "\"" + meth.Name + "\";\n" +

        GenerateArgumentsList(meth) +

        "			_MethodInfo* methodInfo;\n" +
        "			hr = methodfindInType->GetMethod_5(methodName, pToSafeArray(methodArgumentTypes, GetArraySize(methodArgumentTypes), VT_UNKNOWN), &methodInfo);\n" +
        "			if (FAILED(hr))\n" +
        "			{\n" +
        "				wprintf(L" + "\"" + "GetMethod_5 failed " + meth.Name + " w/hr 0x%08lx\", hr);\n" +
        "				pCleanup(pCorRuntimeHost);\n" +
        "				return nullptr;\n" +
        "			}\n" +
        "			return methodInfo;\n" +
        "       }";
                    stringBuilder.Append(h);
                }
            }

            return stringBuilder.ToString() + "\n";
        }

        static void GenerateParmIncludeList(StringBuilder stringBuilder, MethodDef method, TypeDef typedef)
        {
            for (int i = 0; i < method.GetParamCount(); i++)
            {
                var parm = "\n#include " + "\"";
                var parm2 = method.GetParam(i).FullName.Replace(typedef.Namespace, "").Replace(".", "/").Replace("`", "_") + ".h" + "\"";

                if (parm2.StartsWith("/"))
                {
                    parm2 = parm2.Substring(1, parm2.Length - 1); // removed '/'
                }
                /* else
                 {
                     parm2 = "../../" + parm2;
                 }*/

                parm += parm2;

                stringBuilder.Insert(0, parm);
            }
            stringBuilder.AppendLine();
        }

        static string GenerateArgumentsList(MethodDef method)
        {
            StringBuilder stringBuilder = new StringBuilder();

            string str = "";

            for (int i = 0; i < method.GetParamCount(); i++)
            {
                stringBuilder.AppendLine("			_TypePtr " + "argumentType" + i + " = " + method.GetParam(i).FullName.Replace(".", "::").Replace("`", "_") + "::_" + method.GetParam(i).GetName().Replace("`", "_") + ";");
                stringBuilder.AppendLine("			IUnknown* " + "methodArgumentType" + i + "(" + "argumentType" + i + ");");

                str += "methodArgumentType" + i + ", ";
            }

            try
            {
                str = str.Substring(0, str.Length - 2);
            }
            catch (Exception)
            {
                // skip error
            }

            if (method.GetParamCount() == 0)
            {
                stringBuilder.AppendLine("			IUnknown* " + "methodArgumentType0();");
                stringBuilder.AppendLine("			variant_t methodArgumentTypes[] = { methodArgumentType0 };");
            }
            else
            {
                stringBuilder.AppendLine("			variant_t methodArgumentTypes[] = { " + str + " };");
            }

            return stringBuilder.ToString();
        }

        static bool AnalyzeMember(TypeDef type)
        {
            if (type.IsRuntimeSpecialName)
                return false;
            if (type.IsGlobalModuleType)
                return false;
            if (type.IsNotPublic)
                return false;
            if (type.HasGenericParameters)
                return false;
            if (type.CustomAttributes.Count(i => i.TypeFullName.Contains("CompilerGenerated")) != 0)
                return false;
            return true;
        }

        static bool AnalyzeMethod(MethodDef method, TypeDef type)
        {
            if (type.IsGlobalModuleType && method.IsConstructor)
                return false;
            if (method.IsSpecialName)
                return false;
            if (!method.IsPublic)
                return false;
            if (!method.IsStatic)
                return false;
            if (method.IsNative)
                return false;
            if (method.DeclaringType.IsGlobalModuleType)
                return false;
            if (method.HasGenericParameters)
                return false;
            if (method.CustomAttributes.Count(i => i.TypeFullName.Contains("CompilerGenerated")) != 0)
                return false;
            if (method.ReturnType.IsGenericParameter)
                return false;

            for (int i = 0; i < method.GetParamCount(); i++)
            {
                var parm = method.GetParam(i);
                if (parm.FullName.Contains("["))
                    return false;
                if (parm.FullName.Contains("]"))
                    return false;
                if (parm.FullName.Contains("&"))
                    return false;
            }

            return true;
        }
    }
}
